[{"text": "    unsigned long screen_width, screen_height;\n", "label": "CODE"}, {"text": "}\nstd::string Magick::Image::comment(void) const\n", "label": "CODE"}, {"text": "    void test_metaprog()\n    {\n", "label": "CODE"}, {"text": "                return;\n            case '\\n':\n                type = END_OF_LINE;\n                token = \"\\n\";\n                return;\n            case '\\r':\n            case ' ':\n            case '\\t':\n                type = WHITE_SPACE;\n                token = static_cast<char>(ch);\n                ch = streambuf->sgetc();\n                while ((ch == ' ' || ch == '\\t' || ch == '\\r') && ch != EOF)\n", "label": "CODE"}, {"text": "            set_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n", "label": "CODE"}, {"text": "            }\n        }\n        static double gg3(double x)\n        {\n", "label": "CODE"}, {"text": "            temp_image = image();\n", "label": "CODE"}, {"text": "            ++count2;\n", "label": "CODE"}, {"text": "    {\n        read_image( check_file( filename ), NULL, 0L );\n", "label": "CODE"}, {"text": "            DLIB_TEST(  sum(round(1e10*(a - u*w*trans(v)))) == 0);\n            DLIB_TEST((round(1e10*trans(u)*u)  == 1e10*identity_matrix<double,N>()));\n            DLIB_TEST((round(1e10*trans(v)*v)  == 1e10*identity_matrix<double,N>()));\n        }\n        {\n", "label": "CODE"}, {"text": "            test_normal();\n            print_spinner();\n            test_normal_no_bias();\n            print_spinner();\n            test_sparse();\n            print_spinner();\n            test_normal_force_last_weight(false,false);\n            print_spinner();\n            test_normal_force_last_weight(false,true);\n            print_spinner();\n", "label": "CODE"}, {"text": "    using namespace test;\n", "label": "CODE"}, {"text": "    rect_type rect_up2 (\n", "label": "CODE"}, {"text": "                            return false;\n                    }\n                    return true;\n                };\n                matrix<double,0,1> lower(5), upper(5);\n                lower = 0;\n                lower(0) = -4;\n                upper = 4;\n                auto result = find_min_global(f, lower, upper, max_function_calls(40));\n                for (long i = 1; i < result.x.size(); ++i)\n                    result.x(i) += result.x(i-1);\n", "label": "CODE"}, {"text": "        test_find_k_nearest_neighbors_lsh<hash_similar_angles_128>(samples);\n", "label": "CODE"}, {"text": "                        window_table.get_mutex().unlock();\n                        if (disp == 0)\n                        {\n", "label": "CODE"}, {"text": "            py::arg(\"trainer\"),py::arg(\"x\"),py::arg(\"y\"),py::arg(\"folds\"));\n", "label": "CODE"}, {"text": "    class sparse_vector_tester : public tester\n", "label": "CODE"}, {"text": "            const int sbin,\n", "label": "CODE"}, {"text": "            b2.set_size(btn_size,style->get_width());\n", "label": "CODE"}, {"text": "            DLIB_TEST_MSG(rs.mean() < 10.0, rs.mean());\n", "label": "CODE"}, {"text": "    _hclpHuPhash(7)\n", "label": "CODE"}, {"text": "            const tensor_descriptor& dest_desc\n        )\n        {\n", "label": "CODE"}, {"text": "                        const float dx = *p_grad * p_gamma[k];\n                        p_dmeans[k] += -dx*p_invstds[k] + p_dvars[k] * -2*(*p_src - p_means[k])*invnum;\n                        ++p_grad;\n                        ++p_src;\n", "label": "CODE"}, {"text": "            {\n                dlog << LERROR << \"error during bsp_context: \" << e.what();\n                DLIB_TEST(false);\n            }\n        }\n", "label": "CODE"}, {"text": "long matrix_double__len__(matrix<double>& c)\n{\n    return c.nr();\n}\nvoid matrix_double_serialize(const matrix<double>& m, const std::string& file)\n{\n    serialize(file) << m;\n}\n", "label": "CODE"}, {"text": "            if (status == -1 && errno == EINTR)\n", "label": "CODE"}, {"text": "                a = in.get();\n            }\n            if (in.peek() >= '0' && in.peek() <= '9')\n            {\n", "label": "CODE"}, {"text": "                const auto e = std::exp(x);\n                const auto delta = 2*e + e*e + 2;\n                const auto omega = 4*(x + 1) + 4*e*e + e*e*e + e*(4*x + 6);\n                return e*omega/(delta*delta);\n            };\n            if (is_same_object(gradient_input, grad))\n            {\n", "label": "CODE"}, {"text": "            dlog << LINFO;\n", "label": "CODE"}, {"text": "        mutable int i;\n", "label": "CODE"}, {"text": "        DLIB_ASSERT ( current_element_valid() ,\n                \"\\tconst std::string& list_box::element()\"\n                 );\n", "label": "CODE"}, {"text": "Magick::embossImage::embossImage( void )\n  : _radius( 1 ),\n", "label": "CODE"}, {"text": "        cursor_visible = false;\n    }\n    void text_box::\n    adjust_total_rect (\n", "label": "CODE"}, {"text": "        CALL_WITH_N_ARGS(22)\n        CALL_WITH_N_ARGS(23)\n        CALL_WITH_N_ARGS(24)\n        CALL_WITH_N_ARGS(25)\n        CALL_WITH_N_ARGS(26)\n        CALL_WITH_N_ARGS(27)\n        CALL_WITH_N_ARGS(28)\n        CALL_WITH_N_ARGS(29)\n        CALL_WITH_N_ARGS(30)\n        CALL_WITH_N_ARGS(31)\n        CALL_WITH_N_ARGS(32)\n        CALL_WITH_N_ARGS(33)\n        CALL_WITH_N_ARGS(34)\n        CALL_WITH_N_ARGS(35)\n        default:\n            DLIB_CASSERT(false, \"oops\");\n            break;\n    }\n}\n", "label": "CODE"}, {"text": "            sout << \"bobOkgu1/3ExBOTiCjbcxgGrgXw7VdmFURpq+FAQwuNxLDSoNfwFw6ISgP80lgBDV8/5l24p517f\";\n            sout << \"fvNPTCus2I2A", "label": "CODE"}, {"text": "            {\n                unsigned char buf = static_cast<unsigned char>(low>>24);\n                high <<= 8;  \n                low <<= 8;               \n", "label": "CODE"}, {"text": "      isValid(true);\n", "label": "CODE"}, {"text": "                else\n", "label": "CODE"}, {"text": "  ThrowImageException;\n", "label": "CODE"}, {"text": "void Magick::Options::strokeLineCap(const LineCap lineCap_)\n", "label": "CODE"}, {"text": "    void on_open_file (const std::string& file)\n", "label": "CODE"}, {"text": "                swap(vals1, vals2);\n            const double err = equal_error_rate(vals1, vals2).first;\n            dlog << LINFO << \"LDA ERR: \" << err;\n            DLIB_TEST(err == 0);\n", "label": "CODE"}, {"text": "                src_p  += src_sample_size;\n            }\n", "label": "CODE"}, {"text": "        .def(\"__repr__\", &::print_simple_object_detector_training_options)\n        .def_readwrite(\"be_verbose\", &type::be_verbose,\n\"If true, train_simple_object_detector() will print out a lot of information to the screen while training.\")\n        .def_readwrite(\"add_left_right_image_flips\", &type::add_left_right_image_flips,\n", "label": "CODE"}, {"text": "            DLIB_TEST(blocks[i] == sout.str());\n            cr.block(\"all\").block(blocks[i]).get_blocks(temp_blocks);\n            DLIB_TEST(temp_blocks.size() == 0);\n", "label": "CODE"}, {"text": "                cerr << \"The --rm-other-labels option requires you to give one XML file on the command line.\" << endl;\n", "label": "CODE"}, {"text": "    bool entropy_decoder_kernel_2::\n", "label": "CODE"}, {"text": "  point+=buffer;\n  return(point);\n}\nbool Magick::Point::isValid(void) const\n{\n  return(_x > 0.0);\n}\n", "label": "CODE"}, {"text": "    static_assert(std::is_copy_constructible<dlib::optional<trivial_type>>::value, \"bad\");\n", "label": "CODE"}, {"text": "// The contents of this file are in the public domain. See LICENSE_FOR_EXAMPLE_PROGRAMS.txt\n/*\n\n    This example illustrates the use of the HTTP extension to the server object \n    from the dlib C++ Library.\n    It creates a server that always responds with a simple HTML form.\n\n    To view the page this program displays you should go to http://localhost:5000\n\n*/\n", "label": "NONCODE"}, {"text": "// Mark that we are taking the point click so the next call to\n// get_next_double_click() will have to wait for another click.\n", "label": "NONCODE"}, {"text": "// start up the event handler thread\n", "label": "NONCODE"}, {"text": "// Since human faces are generally left-right symmetric we can increase\n// our training dataset by adding mirrored versions of each image back\n// into images_train.  So this next step doubles the size of our\n// training dataset.  Again, this is obviously optional but is useful in\n// many object detection tasks.\n", "label": "NONCODE"}, {"text": "// ----------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// DLIB_USE_CUDA\n", "label": "NONCODE"}, {"text": "// Make sure to cap the max value num can take on so that if it is \n// really large (it might be big on 64bit platforms) so that the OS\n// can't possibly get upset about it being large.\n", "label": "NONCODE"}, {"text": "// compute variances \n", "label": "NONCODE"}, {"text": "// if there is no nth address then return error\n", "label": "NONCODE"}, {"text": "// ------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// color augmentation\n", "label": "NONCODE"}, {"text": "// Create structs\n", "label": "NONCODE"}, {"text": "// put cerr back to the way we found it before running our mex function.\n", "label": "NONCODE"}, {"text": "// and put the chips into the output.\n", "label": "NONCODE"}, {"text": "// tell all the connections to shut down\n", "label": "NONCODE"}, {"text": "// wait for any MoveWindow calls to finish\n", "label": "NONCODE"}, {"text": "// Create predictions for each pixel. At this point, the type of each prediction\n// is an index (a value between 0 and 20). Note that the net may return an image\n// that is not exactly the same size as the input.\n", "label": "NONCODE"}, {"text": "// make test store the point(0,0,0,0,0)\n", "label": "NONCODE"}, {"text": "// create an instance of our web server\n", "label": "NONCODE"}, {"text": "// which side is the click closest to?\n", "label": "NONCODE"}, {"text": "// One thing you can do to reduce the RVM training time is to make its\n// stopping epsilon bigger.  However, this might make the outputs less\n// reliable.  But sometimes it works out well.  0.001 is the default.\n", "label": "NONCODE"}, {"text": "// if the ending is bigger than f's name then it obviously doesn't match\n", "label": "NONCODE"}, {"text": "// Now transform the boxes to the crop and also mark them as ignored if they\n// have already been cropped out or are outside the crop.\n", "label": "NONCODE"}, {"text": "// do nothing, just return to matlab\n", "label": "NONCODE"}, {"text": "// The loop is equivalent to doing this:\n//   m = momentum1*m + (1-momentum1)    *   (weight_decay*params + params_grad);\n//   v = momentum2*v + (1-momentum2)*squared(weight_decay*params + params_grad);\n//   s = -alpha*m/(sqrt(v) + eps);\n", "label": "NONCODE"}, {"text": "/*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) */\n/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK; */\n/*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged */\n/*          superdiagonal elements of an upper bidiagonal matrix B */\n/*          whose diagonal is in S (not necessarily sorted). B */\n/*          satisfies A = U * B * VT, so it has the same singular values */\n/*          as A, and singular vectors related by U and VT. */\n", "label": "NONCODE"}, {"text": "// loop over all the imagenet validation images\n", "label": "NONCODE"}, {"text": "// find the currently best performing function, we will do a trust region\n// step on it.\n", "label": "NONCODE"}, {"text": "/*!\n            requires\n                - current_element_valid() == true\n            ensures\n                - returns a non-const reference to the current element\n        !*/\n", "label": "NONCODE"}, {"text": "// ---------------------------------------------------------------------------------------- \n", "label": "NONCODE"}, {"text": "// now compute the location of the underline bar\n", "label": "NONCODE"}, {"text": "// make sure requires clause is not broken\n", "label": "NONCODE"}, {"text": "// Now map from pyramid coordinates to network_output coordinates.\n", "label": "NONCODE"}, {"text": "// At this point our net object should have learned how to classify MNIST images.  But\n// before we try it out let's save it to disk.  Note that, since the trainer has been\n// running images through the network, net will have a bunch of state in it related to\n// the last batch of images it processed (e.g. outputs from each layer).  Since we\n// don't care about saving that kind of stuff to disk we can tell the network to forget\n// about that kind of transient data so that our file will be smaller.  We do this by\n// \"cleaning\" the network before saving it.\n", "label": "NONCODE"}, {"text": "// if we lost a digit in the subtraction \n", "label": "NONCODE"}, {"text": "// Now that we have a proper join_tree we can use it to obtain a solution to our\n// bayesian network.  Doing this is as simple as declaring an instance of\n// the bayesian_network_join_tree object as follows:\n", "label": "NONCODE"}, {"text": "// Wait for any possible CUDA kernels that might be using our memory block to\n// complete before we free the memory.\n", "label": "NONCODE"}, {"text": "// Paint the square white\n", "label": "NONCODE"}, {"text": "// roll off the bit we just wrote to buf\n", "label": "NONCODE"}, {"text": "// Copyright (C) 2003  Davis E. King (davis@dlib.net)\n// License: Boost Software License   See LICENSE.txt for the full license.\n", "label": "NONCODE"}, {"text": "// now do the task\n", "label": "NONCODE"}, {"text": "// figure out how many characters need to be removed from the path of each file\n", "label": "NONCODE"}, {"text": "/*     .. Scalar Arguments .. */\n/*     .. */\n/*     .. Array Arguments .. */\n/*     .. */\n", "label": "NONCODE"}, {"text": "// Create an instance of our multi-threaded object.   \n", "label": "NONCODE"}, {"text": "// This is equivalent to [v,d] = eigs(m);\n", "label": "NONCODE"}, {"text": "// this is the object we will use to do the data compression\n", "label": "NONCODE"}, {"text": "/*!\n        requires\n            - set is an implementation of static_set/static_set_kernel_abstract.h and\n              is instantiated to hold ints\n        ensures\n            - runs tests on set for compliance with the specs \n    !*/\n", "label": "NONCODE"}, {"text": "// If the training has started and a synchronization file has already been saved to disk,\n// we can re-run this program with the --map option to compute the mean average precision\n// on the test set.\n", "label": "NONCODE"}, {"text": "// -----------------------------------------------------------------------------------\n//  The next block of code outputs python code that populates all the filter weights.\n// -----------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// parse_error\n", "label": "NONCODE"}]