[{"text": "        const std::string str2 = \"[7 [5 [3 The flight] [4 includes [3 a meal]]] [5 [3 The flight] [4 includes [3 a meal]]]]\";\n", "label": "CODE"}, {"text": "#if (MAGICKCORE_QUANTUM_DEPTH < 32) && (MAGICKCORE_SIZEOF_FLOAT_T != MAGICKCORE_SIZEOF_DOUBLE || !defined(MAGICKCORE_HDRI_SUPPORT))\n", "label": "CODE"}, {"text": "        DLIB_TEST(s.find_set(0) == 0);\n", "label": "CODE"}, {"text": "namespace  \n", "label": "CODE"}, {"text": "    const bigint_kernel_1 bigint_kernel_1::\n", "label": "CODE"}, {"text": "    numpy_image<rgb_pixel> temp;\n", "label": "CODE"}, {"text": "                    if (disp == 0)\n", "label": "CODE"}, {"text": "    operator == (\n", "label": "CODE"}, {"text": "        try {\n", "label": "CODE"}, {"text": "            const tensor& gradient_input, \n", "label": "CODE"}, {"text": "            GG (d, a, b, c, x[14], S22, 0xc33707d6); ", "label": "CODE"}, {"text": "        svr_test.set_c(10);\n", "label": "CODE"}, {"text": "            const float eps = 0.01;\n            return (f(+eps)-f(-eps))/(2*eps);\n        };\n", "label": "CODE"}, {"text": "            for (size_t i = 0; i < tmp.size(); ++i)\n", "label": "CODE"}, {"text": "            size_t begin,\n", "label": "CODE"}, {"text": "  return(static_cast<Magick::ColorspaceType>(_quantizeInfo->colorspace));\n}\n", "label": "CODE"}, {"text": "  return(constOptions()->density());\n", "label": "CODE"}, {"text": "            backward_filters_algo = backward_filters_best_algo;\n            config_to_algo_cache[cache_key] = std::make_tuple(forward_algo, backward_data_algo, backward_filters_algo);\n        }\n        void tensor_conv::\n        update_convolution_data_workspace_sizes(\n            const tensor& data,\n            const tensor_descriptor& dest_desc\n        )\n        {\n            CHECK_CUDNN(cudnnGetConvolutionForwardWorkspaceSize(\n                context(),\n", "label": "CODE"}, {"text": "        sin.clear();\n        sin.str(sout.str());\n        sout.str(\"\");\n        compressor.decompress(sin,sout);\n        return sout.str();\n    }\n    logger dlog(\"test.serialize\");\n    void serialize_test (\n    )\n#include <sstream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <dlib/set.h>\n#include \"tester.h\"\nnamespace  \n{\n    using namespace test;\n    using namespace std;\n    using namespace dlib;\n    logger dlog(\"test.set\");\n    template <\n        typename set\n        >\n    void set_compare_test (\n    )\n#include \"tester.h\"\n", "label": "CODE"}, {"text": "        scalar_type eps;\n", "label": "CODE"}, {"text": "        for (auto&& d : dets) {\n", "label": "CODE"}, {"text": "        if (num != scrollable_region::next_free_user_event_number())\n", "label": "CODE"}, {"text": "Magick::ErrorBlob::~ErrorBlob() throw()\n{\n}\nMagick::ErrorCache::ErrorCache(const std::string& what_)\n", "label": "CODE"}, {"text": "            }\n            dlib::image_dataset_metadata::dataset data;\n            load_image_dataset_metadata(data, parser[0]);\n            const auto label = parser.option(\"rm-if-overlaps\").argument();\n            test_box_overlap overlaps(0.5);\n", "label": "CODE"}, {"text": "            auto& faces = batch_faces[i];\n            auto& img = batch_imgs[i];\n            std::vector<chip_details> dets;\n", "label": "CODE"}, {"text": "// The contents of this file are in the public domain. See LICENSE_FOR_EXAMPLE_PROGRAMS.txt\n/*\n\n    This example illustrates the use of the HTTP extension to the server object \n    from the dlib C++ Library.\n    It creates a server that always responds with a simple HTML form.\n\n    To view the page this program displays you should go to http://localhost:5000\n\n*/\n", "label": "NONCODE"}, {"text": "// Mark that we are taking the point click so the next call to\n// get_next_double_click() will have to wait for another click.\n", "label": "NONCODE"}, {"text": "// start up the event handler thread\n", "label": "NONCODE"}, {"text": "// Since human faces are generally left-right symmetric we can increase\n// our training dataset by adding mirrored versions of each image back\n// into images_train.  So this next step doubles the size of our\n// training dataset.  Again, this is obviously optional but is useful in\n// many object detection tasks.\n", "label": "NONCODE"}, {"text": "// ----------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// DLIB_USE_CUDA\n", "label": "NONCODE"}, {"text": "// Make sure to cap the max value num can take on so that if it is \n// really large (it might be big on 64bit platforms) so that the OS\n// can't possibly get upset about it being large.\n", "label": "NONCODE"}, {"text": "// compute variances \n", "label": "NONCODE"}, {"text": "// if there is no nth address then return error\n", "label": "NONCODE"}, {"text": "// ------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// color augmentation\n", "label": "NONCODE"}, {"text": "// Create structs\n", "label": "NONCODE"}, {"text": "// put cerr back to the way we found it before running our mex function.\n", "label": "NONCODE"}, {"text": "// and put the chips into the output.\n", "label": "NONCODE"}, {"text": "// tell all the connections to shut down\n", "label": "NONCODE"}, {"text": "// wait for any MoveWindow calls to finish\n", "label": "NONCODE"}, {"text": "// Create predictions for each pixel. At this point, the type of each prediction\n// is an index (a value between 0 and 20). Note that the net may return an image\n// that is not exactly the same size as the input.\n", "label": "NONCODE"}, {"text": "// make test store the point(0,0,0,0,0)\n", "label": "NONCODE"}, {"text": "// create an instance of our web server\n", "label": "NONCODE"}, {"text": "// which side is the click closest to?\n", "label": "NONCODE"}, {"text": "// One thing you can do to reduce the RVM training time is to make its\n// stopping epsilon bigger.  However, this might make the outputs less\n// reliable.  But sometimes it works out well.  0.001 is the default.\n", "label": "NONCODE"}, {"text": "// if the ending is bigger than f's name then it obviously doesn't match\n", "label": "NONCODE"}, {"text": "// Now transform the boxes to the crop and also mark them as ignored if they\n// have already been cropped out or are outside the crop.\n", "label": "NONCODE"}, {"text": "// do nothing, just return to matlab\n", "label": "NONCODE"}, {"text": "// The loop is equivalent to doing this:\n//   m = momentum1*m + (1-momentum1)    *   (weight_decay*params + params_grad);\n//   v = momentum2*v + (1-momentum2)*squared(weight_decay*params + params_grad);\n//   s = -alpha*m/(sqrt(v) + eps);\n", "label": "NONCODE"}, {"text": "/*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) */\n/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK; */\n/*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged */\n/*          superdiagonal elements of an upper bidiagonal matrix B */\n/*          whose diagonal is in S (not necessarily sorted). B */\n/*          satisfies A = U * B * VT, so it has the same singular values */\n/*          as A, and singular vectors related by U and VT. */\n", "label": "NONCODE"}, {"text": "// loop over all the imagenet validation images\n", "label": "NONCODE"}, {"text": "// find the currently best performing function, we will do a trust region\n// step on it.\n", "label": "NONCODE"}, {"text": "/*!\n            requires\n                - current_element_valid() == true\n            ensures\n                - returns a non-const reference to the current element\n        !*/\n", "label": "NONCODE"}, {"text": "// ---------------------------------------------------------------------------------------- \n", "label": "NONCODE"}, {"text": "// now compute the location of the underline bar\n", "label": "NONCODE"}, {"text": "// make sure requires clause is not broken\n", "label": "NONCODE"}, {"text": "// Now map from pyramid coordinates to network_output coordinates.\n", "label": "NONCODE"}, {"text": "// At this point our net object should have learned how to classify MNIST images.  But\n// before we try it out let's save it to disk.  Note that, since the trainer has been\n// running images through the network, net will have a bunch of state in it related to\n// the last batch of images it processed (e.g. outputs from each layer).  Since we\n// don't care about saving that kind of stuff to disk we can tell the network to forget\n// about that kind of transient data so that our file will be smaller.  We do this by\n// \"cleaning\" the network before saving it.\n", "label": "NONCODE"}, {"text": "// if we lost a digit in the subtraction \n", "label": "NONCODE"}, {"text": "// Now that we have a proper join_tree we can use it to obtain a solution to our\n// bayesian network.  Doing this is as simple as declaring an instance of\n// the bayesian_network_join_tree object as follows:\n", "label": "NONCODE"}, {"text": "// Wait for any possible CUDA kernels that might be using our memory block to\n// complete before we free the memory.\n", "label": "NONCODE"}, {"text": "// Paint the square white\n", "label": "NONCODE"}, {"text": "// roll off the bit we just wrote to buf\n", "label": "NONCODE"}, {"text": "// Copyright (C) 2003  Davis E. King (davis@dlib.net)\n// License: Boost Software License   See LICENSE.txt for the full license.\n", "label": "NONCODE"}, {"text": "// now do the task\n", "label": "NONCODE"}, {"text": "// figure out how many characters need to be removed from the path of each file\n", "label": "NONCODE"}, {"text": "/*     .. Scalar Arguments .. */\n/*     .. */\n/*     .. Array Arguments .. */\n/*     .. */\n", "label": "NONCODE"}, {"text": "// Create an instance of our multi-threaded object.   \n", "label": "NONCODE"}, {"text": "// This is equivalent to [v,d] = eigs(m);\n", "label": "NONCODE"}, {"text": "// this is the object we will use to do the data compression\n", "label": "NONCODE"}, {"text": "/*!\n        requires\n            - set is an implementation of static_set/static_set_kernel_abstract.h and\n              is instantiated to hold ints\n        ensures\n            - runs tests on set for compliance with the specs \n    !*/\n", "label": "NONCODE"}, {"text": "// If the training has started and a synchronization file has already been saved to disk,\n// we can re-run this program with the --map option to compute the mean average precision\n// on the test set.\n", "label": "NONCODE"}, {"text": "// -----------------------------------------------------------------------------------\n//  The next block of code outputs python code that populates all the filter weights.\n// -----------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// parse_error\n", "label": "NONCODE"}]