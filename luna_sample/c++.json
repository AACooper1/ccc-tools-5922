[{"text": "// The contents of this file are in the public domain. See LICENSE_FOR_EXAMPLE_PROGRAMS.txt\n/*\n\n    This example illustrates the use of the HTTP extension to the server object \n    from the dlib C++ Library.\n    It creates a server that always responds with a simple HTML form.\n\n    To view the page this program displays you should go to http://localhost:5000\n\n*/\n", "label": "NONCODE"}, {"text": "// Mark that we are taking the point click so the next call to\n// get_next_double_click() will have to wait for another click.\n", "label": "NONCODE"}, {"text": "// start up the event handler thread\n", "label": "NONCODE"}, {"text": "// Since human faces are generally left-right symmetric we can increase\n// our training dataset by adding mirrored versions of each image back\n// into images_train.  So this next step doubles the size of our\n// training dataset.  Again, this is obviously optional but is useful in\n// many object detection tasks.\n", "label": "NONCODE"}, {"text": "// ----------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// DLIB_USE_CUDA\n", "label": "NONCODE"}, {"text": "// Make sure to cap the max value num can take on so that if it is \n// really large (it might be big on 64bit platforms) so that the OS\n// can't possibly get upset about it being large.\n", "label": "NONCODE"}, {"text": "// compute variances \n", "label": "NONCODE"}, {"text": "// if there is no nth address then return error\n", "label": "NONCODE"}, {"text": "// ------------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// color augmentation\n", "label": "NONCODE"}, {"text": "// Create structs\n", "label": "NONCODE"}, {"text": "// put cerr back to the way we found it before running our mex function.\n", "label": "NONCODE"}, {"text": "// and put the chips into the output.\n", "label": "NONCODE"}, {"text": "// tell all the connections to shut down\n", "label": "NONCODE"}, {"text": "// wait for any MoveWindow calls to finish\n", "label": "NONCODE"}, {"text": "// Create predictions for each pixel. At this point, the type of each prediction\n// is an index (a value between 0 and 20). Note that the net may return an image\n// that is not exactly the same size as the input.\n", "label": "NONCODE"}, {"text": "// make test store the point(0,0,0,0,0)\n", "label": "NONCODE"}, {"text": "// create an instance of our web server\n", "label": "NONCODE"}, {"text": "// which side is the click closest to?\n", "label": "NONCODE"}, {"text": "// One thing you can do to reduce the RVM training time is to make its\n// stopping epsilon bigger.  However, this might make the outputs less\n// reliable.  But sometimes it works out well.  0.001 is the default.\n", "label": "NONCODE"}, {"text": "// if the ending is bigger than f's name then it obviously doesn't match\n", "label": "NONCODE"}, {"text": "// Now transform the boxes to the crop and also mark them as ignored if they\n// have already been cropped out or are outside the crop.\n", "label": "NONCODE"}, {"text": "// do nothing, just return to matlab\n", "label": "NONCODE"}, {"text": "// The loop is equivalent to doing this:\n//   m = momentum1*m + (1-momentum1)    *   (weight_decay*params + params_grad);\n//   v = momentum2*v + (1-momentum2)*squared(weight_decay*params + params_grad);\n//   s = -alpha*m/(sqrt(v) + eps);\n", "label": "NONCODE"}, {"text": "/*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) */\n/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK; */\n/*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged */\n/*          superdiagonal elements of an upper bidiagonal matrix B */\n/*          whose diagonal is in S (not necessarily sorted). B */\n/*          satisfies A = U * B * VT, so it has the same singular values */\n/*          as A, and singular vectors related by U and VT. */\n", "label": "NONCODE"}, {"text": "// loop over all the imagenet validation images\n", "label": "NONCODE"}, {"text": "// find the currently best performing function, we will do a trust region\n// step on it.\n", "label": "NONCODE"}, {"text": "/*!\n            requires\n                - current_element_valid() == true\n            ensures\n                - returns a non-const reference to the current element\n        !*/\n", "label": "NONCODE"}, {"text": "// ---------------------------------------------------------------------------------------- \n", "label": "NONCODE"}, {"text": "// now compute the location of the underline bar\n", "label": "NONCODE"}, {"text": "// make sure requires clause is not broken\n", "label": "NONCODE"}, {"text": "// Now map from pyramid coordinates to network_output coordinates.\n", "label": "NONCODE"}, {"text": "// At this point our net object should have learned how to classify MNIST images.  But\n// before we try it out let's save it to disk.  Note that, since the trainer has been\n// running images through the network, net will have a bunch of state in it related to\n// the last batch of images it processed (e.g. outputs from each layer).  Since we\n// don't care about saving that kind of stuff to disk we can tell the network to forget\n// about that kind of transient data so that our file will be smaller.  We do this by\n// \"cleaning\" the network before saving it.\n", "label": "NONCODE"}, {"text": "// if we lost a digit in the subtraction \n", "label": "NONCODE"}, {"text": "// Now that we have a proper join_tree we can use it to obtain a solution to our\n// bayesian network.  Doing this is as simple as declaring an instance of\n// the bayesian_network_join_tree object as follows:\n", "label": "NONCODE"}, {"text": "// Wait for any possible CUDA kernels that might be using our memory block to\n// complete before we free the memory.\n", "label": "NONCODE"}, {"text": "// Paint the square white\n", "label": "NONCODE"}, {"text": "// roll off the bit we just wrote to buf\n", "label": "NONCODE"}, {"text": "// Copyright (C) 2003  Davis E. King (davis@dlib.net)\n// License: Boost Software License   See LICENSE.txt for the full license.\n", "label": "NONCODE"}, {"text": "// now do the task\n", "label": "NONCODE"}, {"text": "// figure out how many characters need to be removed from the path of each file\n", "label": "NONCODE"}, {"text": "/*     .. Scalar Arguments .. */\n/*     .. */\n/*     .. Array Arguments .. */\n/*     .. */\n", "label": "NONCODE"}, {"text": "// Create an instance of our multi-threaded object.   \n", "label": "NONCODE"}, {"text": "// This is equivalent to [v,d] = eigs(m);\n", "label": "NONCODE"}, {"text": "// this is the object we will use to do the data compression\n", "label": "NONCODE"}, {"text": "/*!\n        requires\n            - set is an implementation of static_set/static_set_kernel_abstract.h and\n              is instantiated to hold ints\n        ensures\n            - runs tests on set for compliance with the specs \n    !*/\n", "label": "NONCODE"}, {"text": "// If the training has started and a synchronization file has already been saved to disk,\n// we can re-run this program with the --map option to compute the mean average precision\n// on the test set.\n", "label": "NONCODE"}, {"text": "// -----------------------------------------------------------------------------------\n//  The next block of code outputs python code that populates all the filter weights.\n// -----------------------------------------------------------------------------------\n", "label": "NONCODE"}, {"text": "// parse_error\n", "label": "NONCODE"}]